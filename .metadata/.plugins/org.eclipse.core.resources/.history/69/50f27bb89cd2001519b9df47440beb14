package binary.search.recursive;

public class BinarySearchRecursive {

	static int A[] = { 3, 3, 6, 112, 112, 112} ; 

	public static void main(String[] args) {

		int start = 0 ;
		int end = A.length - 1 ;

		int x = 8 ;
		int index = BSearch_normal(A, x, start, end) ;
		System.out.println( x + " was found at index :" + index);


		x = 112 ;
		index = BSearch_normal(A, x, start, end) ;
		System.out.println( x + " was found at index ( Normal) :" + index);

		index = BSearch_first(A, x, start, end) ;
		System.out.println( x + " was found at index ( First) :" + index);

		index = BSearch_last(A, x, start, end) ;
		System.out.println( x + " was found at index ( Last) :" + index);


		System.out.println("---------------------------------------------------");
		x = 3 ;
		index = BSearch_normal(A, x, start, end) ;
		System.out.println( x + " was found at index ( Normal) :" + index);

		index = BSearch_first(A, x, start, end) ;
		System.out.println( x + " was found at index ( First) :" + index);

		index = BSearch_last(A, x, start, end) ;
		System.out.println( x + " was found at index ( Last) :" + index);	
	}

	/** 
	 * This is the binary search in its simplest form.
	 * It will be able to return the index of every element found, if not -1.
	 * In case there are duplicates 
	 * @param a
	 * @param x
	 * @param start
	 * @param end
	 * @return
	 */
	private static int BSearch_normal(int[] a, int x, int start, int end) {

		// 1 Base condition		
		if( start > end)
			return -1 ;

		// 2 Base condition

		if( (start == end) && (x == a[start])){
			return start ;
		}


		int mid = (start + end ) /2 ;

		if( x < A[ mid]){

			return BSearch_normal(a, x, start, mid -1) ;

		}

		else if( x > A[mid]){

			return BSearch_normal(a, x, mid +1, end ) ;

		}

		else if ( x == A[mid]){

			return mid ;

		}

		else{

			return -1 ;
		}
	}


	private static int BSearch_first(int[] a, int x, int start, int end) {

		// 1 Base condition		
		if( start > end)
			return -1 ;

		// 2 Base condition

		if( (x == a[start])){
			return start ;
		}


		int mid = (start + end ) /2 ;

		if ( x == A[mid])
			return mid ;

		else if( x < A[ mid])
			return BSearch_first(a, x, start, mid -1) ;

		else if( x > A[mid])
			return BSearch_first(a, x, mid +1, end ) ;

		else
			return -1;
	}


	private static int BSearch_last(int[] a, int x, int start, int end) {
		// 1 Base condition		
		if( start > end)
			return -1 ;

		// 2 Base condition

		if( (x == a[end])){
			return end ;
		}


		int mid = (start + end ) /2 ;

		if ( x == A[mid])
			return mid ;

		else if( x < A[ mid])
			return BSearch_last(a, x, start, mid -1) ;

		else if( x > A[mid])
			return BSearch_last(a, x, mid +1, end ) ;

		else
			return -1 ;

	}


}
